
### 10.1 引言

信号是软件中断。

信号提供了一种处理异步事件的方法。

### 10.2 信号概念

不存在编号为0的信号。`kill`函数对信号编号为0有特殊对应用，此种信号编号也称为空信号。

很多条件可以产生信号：
- 用户按下某些终端键时，引发终端产生的信号。如果Ctrl+C 
- 硬件产生的信号：除数为0、无效的内存引用等。
- 进程调用`kill`函数可将任意信号发送给另一个进程或进程组
- 用户可用`kill`命令将信号发送给其他进程
- 当检测到某种软件条件已经发生，并应将其通知有关进程时也产生信号。例如SIGURG（网络连接上传来带外的数据）、SIGPIPE（在管道的读进程已终止后，一个进程写此管道）以及SIGALRM(进程所设置的定时器已经超时)

信号是异步事件的经典实例。产生信号的事件对进程而言是随机出现对。进程不能简单地测试一个变量来判断是否发生了一个信号，而是必须告诉内核“在此信号发生时，请执行下列操作”。

信号的处理：
- 忽略此信号。大多数信号都可以使用这种方式处理，但是两种信号不能被忽略。它们是`SIGKILL`和`SIGSTOP`。这两种信号不能被忽略的原因是：它们向内核和超级用户提供了使进程终止或停止的可靠方法。
- 捕捉信号。为了做到这一点，要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可执行用户希望对这种事件进行的处理。例如，编写一个命令解释器，它将用户的输入解释为命令并执行，当用户键盘产生中断信号后，希望该命令解释器返回到主循环，终止正在为该用户执行的命令。如果捕捉到`SIGCHLD`信号，则表示一个子进程已经终止，所以此信号的捕捉函数可以调用`waitpid`以取得该子进程的进程ID以及它的终止状态。**注意，不能捕捉`SIGKILL`和`SIGSTOP`信号**
- 执行系统默认动作。对大多数信号的系统默认动作就是终止该进程。

### 10.3 函数signal

### 10.4 不可靠的信号

### 10.5 中断的系统调用

### 10.6 可重入函数

可重入函数简单对就是可以被中断的函数，也就是说，可以在这个函数执行的任何时刻中断它，转而OS调度下去执行另外一段代码，而返回控制时不会出现什么错误。
进程捕捉到信号并对其进行处理时，进程正在执行的正常指令序列就被信号处理程序临时中断，它首先执行该信号处理程序中的指令。如果从信号处理程序返回（例如没有调用`exit`或`longjump`），则继续执行在捕捉到信号时进程正在执行的正常指令序列。但在信号处理程序中，不能判断捕捉信号时进程执行到何处。如果进程正在执行`malloc`，在其堆中分配另外到存储空间，而此时由于捕捉到信号而插入执行该信号处理程序，其中又调用`malloc`函数，可能会对进程造成破坏。

**简单的说，在信号处理函数中，不要调用不可重入函数，会对进程对数据结构造成损坏，不可预知结果。**

### 10.7 SIGCLD语义

`SIGCLD`的语义为：子进程状态改变后产生此信号，父进程需要调用一个`wait`函数以确定发生了什么。

对于`SIGCLD`早期的处理方式是：
1. 如果进程明确地将该信号的配置设置为`SIG_IGN`，则调用进程的子进程将不产生僵死进程。这与默认动作`SIG_DFL`不同。子进程在终止时，将其状态丢弃。如果调用进程随后调用一个`wait`函数，那么它将阻塞直到所有子进程都终止，然后该`wait`会返回-1，并将其`errno`设置为`ECHILD`。

2. 如果将`SIGCLD`的配置设置为捕捉，则内核立即检查是否有子进程准备好被等待，如果是这样，则调用`SIGCLD`处理程序。

一般，父进程在生成子进程后有两种情况，一种是父进程继续做别的事情，一种是父进程啥也不做，一直在`wait`子进程退出。`SIGCLD`信号就是为第一种情况准备的，它让父进程去做别的事情，而只要父进程注册了处理该信号的函数，在子进程退出时就会调用该函数，在该函数中又可以调用`wait`得到终止的子进程的状态。处理信号函数执行完后，再继续父进程的事情。也就是说，如果父进程`fork`之后调用`wait`，就会阻塞，直到有一个子进程退出。
如果父进程在`fork`之前先注册了`SIGCLD`的信号处理函数，然后做自己的事情。当子进程退出时，会给父进程发送一个`SIGCLD`信号，然后信号处理函数就会执行。可以在信号处理函数中调用`wait`获得子进程退出时的状态，并且此时`wait`不会阻塞，当韩式执行完成后，父进程又可以做自己的事情。